using System.Text;
using System.Text.Json;

namespace StateleSSE.CodeGen.TypeScript;

/// <summary>
/// Generates TypeScript EventSource client code from OpenAPI specification
/// </summary>
public static class TypeScriptSseGenerator
{
    /// <summary>
    /// Generates TypeScript EventSource client from OpenAPI spec
    /// </summary>
    /// <param name="openApiSpecPath">Path to OpenAPI JSON file (e.g., "openapi-with-docs.json")</param>
    /// <param name="outputPath">Output path for generated TypeScript file</param>
    /// <param name="baseUrlImport">Import path for BASE_URL (default: "./utils/BASE_URL")</param>
    public static void Generate(
        string openApiSpecPath,
        string outputPath,
        string baseUrlImport = "./utils/BASE_URL")
    {
        if (!File.Exists(openApiSpecPath))
            throw new FileNotFoundException($"OpenAPI spec not found: {openApiSpecPath}");

        var spec = JsonDocument.Parse(File.ReadAllText(openApiSpecPath));
        var endpoints = FindEventSourceEndpoints(spec);

        if (endpoints.Count == 0)
        {
            Console.WriteLine("⚠️  No EventSource endpoints found (none marked with [EventSourceEndpoint])");
            return;
        }

        var typescript = GenerateTypeScript(endpoints, baseUrlImport);

        File.WriteAllText(outputPath, typescript);

        Console.WriteLine($"✅ Generated EventSource client at: {outputPath}");
        Console.WriteLine($"   {endpoints.Count} endpoints generated");
    }

    private static List<SseEndpoint> FindEventSourceEndpoints(JsonDocument spec)
    {
        var endpoints = new List<SseEndpoint>();

        if (!spec.RootElement.TryGetProperty("paths", out var paths))
            return endpoints;

        foreach (var pathProp in paths.EnumerateObject())
        {
            var path = pathProp.Name;

            if (!pathProp.Value.TryGetProperty("get", out var operation))
                continue;

            // Check for x-event-source extension
            if (!operation.TryGetProperty("x-event-source", out var isEventSource) ||
                !isEventSource.GetBoolean())
                continue;

            var eventType = operation.TryGetProperty("x-event-type", out var evtType)
                ? evtType.GetString()
                : path.TrimStart('/');

            var operationId = operation.TryGetProperty("operationId", out var opId)
                ? opId.GetString()
                : null;

            var summary = operation.TryGetProperty("summary", out var sum)
                ? sum.GetString()
                : null;

            var parameters = new List<SseParameter>();
            if (operation.TryGetProperty("parameters", out var paramsArray))
            {
                foreach (var param in paramsArray.EnumerateArray())
                {
                    if (param.TryGetProperty("in", out var paramIn) &&
                        paramIn.GetString() == "query" &&
                        param.TryGetProperty("name", out var paramName))
                    {
                        var paramType = "string";
                        if (param.TryGetProperty("schema", out var schema) &&
                            schema.TryGetProperty("type", out var schemaType))
                        {
                            paramType = MapType(schemaType.GetString());
                        }

                        parameters.Add(new SseParameter(
                            paramName.GetString()!,
                            paramType
                        ));
                    }
                }
            }

            endpoints.Add(new SseEndpoint(
                path,
                eventType!,
                operationId,
                summary,
                parameters
            ));
        }

        return endpoints;
    }

    private static string GenerateTypeScript(
        List<SseEndpoint> endpoints,
        string baseUrlImport)
    {
        var sb = new StringBuilder();

        // Imports
        sb.AppendLine($"import {{ BASE_URL }} from '{baseUrlImport}';");
        sb.AppendLine();

        // Header comment
        sb.AppendLine("/**");
        sb.AppendLine(" * Auto-generated EventSource client");
        sb.AppendLine(" * Generated by StateleSSE.CodeGen.Typescript NuGet package");
        sb.AppendLine(" * DO NOT EDIT MANUALLY");
        sb.AppendLine(" */");
        sb.AppendLine();

        // Generate function for each endpoint
        foreach (var endpoint in endpoints)
        {
            var functionName = GenerateFunctionName(endpoint);
            var paramList = string.Join(", ", endpoint.Parameters.Select(p =>
                $"{p.Name.ToLowerInvariant()}: {p.Type}"));
            var paramNames = string.Join(", ", endpoint.Parameters.Select(p => p.Name.ToLowerInvariant()));

            sb.AppendLine("/**");
            sb.AppendLine($" * {endpoint.Summary ?? $"Subscribe to {endpoint.EventType} events"}");
            foreach (var param in endpoint.Parameters)
            {
                sb.AppendLine($" * @param {param.Name.ToLowerInvariant()} - {param.Name}");
            }
            sb.AppendLine($" * @returns EventSource instance for {endpoint.EventType}");
            sb.AppendLine(" */");
            sb.AppendLine($"export function {functionName}({paramList}): EventSource {{");
            sb.AppendLine($"    const queryParams = new URLSearchParams({{ {paramNames} }});");
            sb.AppendLine($"    const url = `${{BASE_URL}}{endpoint.Path}?${{queryParams}}`;");
            sb.AppendLine("    return new EventSource(url);");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Generic helper
        sb.AppendLine("/**");
        sb.AppendLine(" * Generic EventSource helper with typed callbacks");
        sb.AppendLine(" */");
        sb.AppendLine("export function createTypedEventStream<T>(");
        sb.AppendLine("    url: string,");
        sb.AppendLine("    onMessage: (event: T) => void,");
        sb.AppendLine("    onError?: (error: Event) => void");
        sb.AppendLine("): EventSource {");
        sb.AppendLine("    const es = new EventSource(url);");
        sb.AppendLine();
        sb.AppendLine("    es.onmessage = (e) => {");
        sb.AppendLine("        try {");
        sb.AppendLine("            const data: T = JSON.parse(e.data);");
        sb.AppendLine("            onMessage(data);");
        sb.AppendLine("        } catch (error) {");
        sb.AppendLine("            console.error('Failed to parse SSE event:', error);");
        sb.AppendLine("        }");
        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    if (onError) {");
        sb.AppendLine("        es.onerror = onError;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    return es;");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateFunctionName(SseEndpoint endpoint)
    {
        if (endpoint.OperationId != null && endpoint.OperationId.Contains('_'))
        {
            var parts = endpoint.OperationId.Split('_');
            var functionName = parts[^1];
            return char.ToLowerInvariant(functionName[0]) + functionName[1..];
        }

        return $"subscribe{endpoint.EventType}";
    }

    private static string MapType(string? openApiType) => openApiType switch
    {
        "string" => "string",
        "integer" => "number",
        "number" => "number",
        "boolean" => "boolean",
        "array" => "any[]",
        _ => "any"
    };

    private record SseEndpoint(
        string Path,
        string EventType,
        string? OperationId,
        string? Summary,
        List<SseParameter> Parameters
    );

    private record SseParameter(string Name, string Type);
}
